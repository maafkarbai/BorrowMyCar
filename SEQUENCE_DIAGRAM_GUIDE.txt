BORROWMYCAR SEQUENCE DIAGRAM DOCUMENTATION
==========================================

PROJECT OVERVIEW
----------------
BorrowMyCar is a full-stack car rental platform for the UAE market featuring:
- Node.js/Express backend with MongoDB
- React frontend with Vite
- JWT authentication
- Stripe payment integration
- Cloudinary image storage
- Mapbox location services

KEY ACTORS IN SEQUENCES
-----------------------
1. Renter (Tourist/Local user who books cars)
2. Owner (Car owner who lists vehicles)
3. Admin (Platform administrator)
4. System (Backend API)
5. Database (MongoDB)
6. External Services:
   - Stripe API
   - Cloudinary API
   - Mapbox API

MAIN SEQUENCE FLOWS
===================

1. USER REGISTRATION AND VERIFICATION FLOW
------------------------------------------
Actors: User, Frontend, Backend, Database, Cloudinary, Admin

Sequence:
1. User fills registration form (name, email, password, role selection)
2. User uploads documents (Emirates ID/Visa, Driving License)
3. Frontend sends POST /api/auth/signup with multipart form data
4. Backend validates input using validateUserData()
5. Backend uploads documents to Cloudinary via uploadImagesToCloud()
6. Backend hashes password with bcrypt
7. Backend creates User record with isApproved=false
8. Backend returns JWT token
9. User account created but limited (cannot book/list until approved)
10. Admin reviews documents in admin dashboard
11. Admin sets isApproved=true
12. User gains full access based on role

Key Files:
- controllers/authController.js
- models/User.js
- utils/validators.js
- utils/cloudUploader.js
- middlewares/multer.js

2. USER LOGIN FLOW
------------------
Actors: User, Frontend, Backend, Database

Sequence:
1. User enters email and password
2. Frontend sends POST /api/auth/login
3. Backend validates credentials
4. Backend checks password with bcrypt.compare()
5. Backend generates JWT token
6. Token stored in localStorage/cookie
7. Frontend updates AuthContext
8. User redirected to dashboard/home

Key Files:
- controllers/authController.js
- borrowmycarfrontend/src/Login.jsx
- borrowmycarfrontend/src/context/AuthContext.jsx
- middlewares/authMiddleware.js

3. CAR LISTING FLOW (OWNER)
---------------------------
Actors: Owner, Frontend, Backend, Database, Cloudinary

Sequence:
1. Owner fills car listing form
2. Owner uploads multiple car images
3. Owner sets availability dates (from/to)
4. Frontend sends POST /api/cars with multipart data
5. Backend validates with validateCarData()
6. Backend sanitizes input with sanitizeCarData()
7. Backend uploads images to Cloudinary
8. Backend creates Car record with status="active"
9. Car saved with owner reference
10. Success response with car details

Key Files:
- controllers/carController.js
- models/Car.js
- borrowmycarfrontend/src/ListCar.jsx
- utils/validators.js
- utils/cloudinary.js

4. CAR BROWSING AND SEARCH FLOW
--------------------------------
Actors: User (any), Frontend, Backend, Database, Mapbox

Sequence:
1. User accesses browse cars page
2. User applies filters (city, price, transmission, etc.)
3. Frontend sends GET /api/cars with query params
4. Backend parses filters
5. Backend queries MongoDB with filters
6. Backend implements pagination
7. For location-based search:
   a. Frontend gets user location
   b. Sends coordinates to backend
   c. Backend uses MongoDB geospatial queries
   d. Returns cars sorted by distance
8. Frontend displays car cards
9. Mapbox shows car locations on map

Key Files:
- controllers/carController.js
- borrowmycarfrontend/src/BrowseCars.jsx
- borrowmycarfrontend/src/components/CarFilterBar.jsx
- borrowmycarfrontend/src/components/Mapbox/CarLocationMap.jsx
- utils/locationUtils.js

5. BOOKING CREATION FLOW
------------------------
Actors: Renter, Frontend, Backend, Database, Stripe

Sequence:
1. Renter selects car and dates
2. Frontend validates date selection
3. Frontend sends POST /api/bookings
4. Backend checks:
   a. User is approved (isApproved=true)
   b. Car is available in date range
   c. No overlapping bookings exist
5. Backend calculates total price
6. Backend creates pending booking
7. Frontend redirects to payment
8. Stripe payment modal opens
9. User enters card details
10. Frontend sends payment to Stripe
11. On success, backend updates booking status
12. Confirmation email sent
13. Owner notified of new booking

Key Files:
- controllers/bookingController.js
- models/Booking.js
- borrowmycarfrontend/src/CarDetails.jsx
- borrowmycarfrontend/src/components/PaymentModal.jsx
- config/stripe.js
- utils/BookingValidation.js

6. PAYMENT PROCESSING FLOW
--------------------------
Actors: Renter, Frontend, Stripe API, Backend, Database

Sequence:
1. Payment modal receives booking details
2. Stripe Elements loaded in frontend
3. User enters payment information
4. Frontend creates payment intent
5. Stripe processes payment
6. On success:
   a. Frontend receives payment confirmation
   b. Backend webhook triggered
   c. Booking status updated to "approved"
   d. Payment record created
7. On failure:
   a. Error displayed to user
   b. Booking remains pending
   c. Retry option provided

Key Files:
- controllers/paymentController.js
- borrowmycarfrontend/src/components/PaymentForm.jsx
- borrowmycarfrontend/src/context/PaymentContext.jsx
- config/stripe.js
- routes/paymentRoutes.js

7. BOOKING MANAGEMENT FLOW (OWNER)
----------------------------------
Actors: Owner, Frontend, Backend, Database

Sequence:
1. Owner accesses dashboard
2. Frontend sends GET /api/bookings/owner
3. Backend returns owner's car bookings
4. Owner reviews pending bookings
5. Owner approves/rejects booking
6. Frontend sends PUT /api/bookings/:id/status
7. Backend updates booking status
8. Renter notified of status change
9. If rejected, payment refunded via Stripe

Key Files:
- controllers/bookingController.js
- borrowmycarfrontend/src/SellerDashboard.jsx
- models/Booking.js

8. USER PROFILE UPDATE FLOW
---------------------------
Actors: User, Frontend, Backend, Database, Cloudinary

Sequence:
1. User accesses profile page
2. User updates information
3. If profile picture changed:
   a. Image uploaded to Cloudinary
   b. Old image deleted
4. Frontend sends PUT /api/users/profile
5. Backend validates changes
6. Backend updates User record
7. Updated user data returned
8. AuthContext refreshed

Key Files:
- controllers/authController.js
- borrowmycarfrontend/src/Profile.jsx
- borrowmycarfrontend/src/components/ProfilePictureManager.jsx
- models/User.js

9. LOCATION-BASED FEATURES FLOW
--------------------------------
Actors: User, Frontend, Mapbox API, Backend

Sequence:
1. User allows location access
2. Frontend gets coordinates
3. For car search:
   a. Coordinates sent to backend
   b. Geospatial query executed
   c. Nearby cars returned
4. For route planning:
   a. Start/end points sent to Mapbox
   b. Directions API returns route
   c. Route displayed on map
5. For address autocomplete:
   a. User types address
   b. Mapbox Geocoding API queried
   c. Suggestions displayed
   d. Selected location saved

Key Files:
- utils/mapboxUtils.js
- borrowmycarfrontend/src/components/LocationPicker.jsx
- borrowmycarfrontend/src/components/DeliveryLocationPicker.jsx
- config/mapbox.js

10. ADMIN VERIFICATION FLOW
---------------------------
Actors: Admin, Frontend, Backend, Database

Sequence:
1. Admin logs in with special credentials
2. Admin accesses verification dashboard
3. Frontend sends GET /api/admin/pending-users
4. Backend returns unverified users
5. Admin reviews documents
6. Admin approves/rejects user
7. Frontend sends PUT /api/admin/users/:id/verify
8. Backend updates isApproved status
9. User notified via email
10. User gains/loses platform access

Key Files:
- controllers/authController.js (admin functions)
- borrowmycarfrontend/src/AdminDashboard.jsx
- middlewares/authMiddleware.js (restrictTo)

ERROR HANDLING SEQUENCES
========================

1. Authentication Errors
- Invalid credentials → 401 response
- Token expired → Redirect to login
- Unauthorized access → 403 response

2. Validation Errors
- Invalid input → 400 with field errors
- Missing required fields → 400 response
- Invalid file types → 400 response

3. Booking Conflicts
- Double booking attempt → 409 conflict
- Unavailable dates → 400 response
- Unapproved user → 403 response

4. Payment Failures
- Card declined → Show error, keep booking pending
- Network timeout → Retry mechanism
- Webhook failure → Manual reconciliation

5. External Service Failures
- Cloudinary down → Fallback to local storage
- Mapbox unavailable → Hide location features
- Stripe issues → Alternative payment methods

MIDDLEWARE CHAINS
=================

Protected Routes:
Request → authMiddleware.protect → Controller → Response

Admin Routes:
Request → authMiddleware.protect → authMiddleware.restrictTo('admin') → Controller → Response

File Upload Routes:
Request → multer.upload → cloudUploader → Controller → Response

WEBSOCKET SEQUENCES (Future Implementation)
===========================================

Real-time Notifications:
1. User action triggers event
2. Backend emits socket event
3. Connected clients receive update
4. UI updates without refresh

Live Booking Updates:
1. Owner approves booking
2. Socket event sent to renter
3. Renter sees instant status change
4. Payment processing triggered

DATABASE RELATIONSHIPS
======================

User → Car (One-to-Many)
- User can own multiple cars
- Car belongs to one owner

User → Booking (One-to-Many as Renter)
- User can make multiple bookings
- Booking belongs to one renter

Car → Booking (One-to-Many)
- Car can have multiple bookings
- Booking references one car

Booking States:
- pending: Initial state
- approved: Owner/auto approved
- rejected: Owner rejected
- completed: Rental finished
- cancelled: User cancelled

TESTING SEQUENCES
=================

Unit Test Flow:
1. Setup test database
2. Create test fixtures
3. Execute test cases
4. Verify outcomes
5. Cleanup test data

Integration Test Flow:
1. Start test server
2. Create test users
3. Simulate full user flows
4. Verify API responses
5. Check database state

E2E Test Flow:
1. Launch browser
2. Navigate application
3. Perform user actions
4. Verify UI changes
5. Check backend effects

DEPLOYMENT SEQUENCES
====================

Build Process:
1. Run tests
2. Build frontend (Vite)
3. Optimize images
4. Set production env
5. Deploy to hosting

Database Migration:
1. Backup current data
2. Run migration scripts
3. Verify data integrity
4. Update indexes
5. Clear cache

MONITORING SEQUENCES
====================

Error Tracking:
1. Error occurs
2. Error handler captures
3. Log to monitoring service
4. Alert sent if critical
5. Developer investigates

Performance Monitoring:
1. Request received
2. Middleware tracks timing
3. Database queries logged
4. Response time recorded
5. Metrics aggregated

NOTES FOR DIAGRAM CREATION
==========================

1. Use standard UML sequence diagram notation
2. Show async operations with dashed lines
3. Include error paths as alternative flows
4. Group related sequences in single diagrams
5. Show external service calls distinctly
6. Include timing constraints where relevant
7. Document preconditions and postconditions
8. Show data transformations between actors
9. Include security checks in sequences
10. Document retry and fallback mechanisms

TOOLS RECOMMENDED
=================
- PlantUML for text-based diagrams
- Draw.io for visual editing
- Mermaid for markdown integration
- Lucidchart for collaboration
- Visual Paradigm for comprehensive UML

KEY INTEGRATION POINTS
======================
- JWT tokens in Authorization headers
- Multipart form data for file uploads
- Query parameters for filtering
- Webhook endpoints for Stripe
- WebSocket connections for real-time
- Geospatial queries for location search
- Transaction handling for bookings
- Pagination for large datasets
- Rate limiting for API protection
- Caching for performance

This document provides the foundation for creating detailed sequence diagrams for all major flows in the BorrowMyCar application.